// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "TetrischedService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <deque>
#include <vector>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace alsched;

class TetrischedServiceHandler : virtual public TetrischedServiceIf
{
private:
    struct QueueJob {
        JobID jobId;
        int32_t k;
        QueueJob(JobID jobId, int32_t k) {
            this->jobId = jobId;
            this->k = k;
        }
    };

    struct MachineResource{
        int machineID;
        bool isFree;
        MachineResource(int machineID) {
            this->machineID = machineID;
            this->isFree = true;
        }
    };

    std::deque<QueueJob> queue;
    std::vector<std::vector<MachineResource>> racks;

    std::vector<int> ReadConfigFile() {
        std::ifstream t("config-mini");

        char c;
        std::string str;
        while(t.get(c)) {
            str += c;
        }
        const char *cstr = str.c_str();
        rapidjson::Document d;
        d.Parse(cstr);
        

        const rapidjson::Value& a = d["rack_cap"]; // Using a reference for consecutive access is handy and faster.
        
        std::vector<int> rv;
        for (SizeType i = 0; i < a.Size(); i++) // rapidjson uses SizeType instead of size_t.
            rv.push_back(a[i].GetInt());

        return rv;
    }

    int GetFreeMachinesNum() {
        int count = 0;
        for (int i = 0; i < racks.size(); i++)
            for (int j = 0; j < racks[i].size(); j++)
                if (racks[i][j].isFree)
                    count++;
        return count;
    }

    int GetNextFreeMachine() {
        for (int i = 0; i < racks.size(); i++)
            for (int j = 0; j < racks[i].size(); j++)
                if (racks[i][j].isFree)
                    return racks[i][j].machineID;
        return -1;
    }

    void FreeMachine(int id) {
        int rackID = 0;
        while (id >= racks[rackID].size()) {
            id -= racks[rackID].size();
            rackID++;
        }
        racks[rackID][id].isFree = true;
    }

    void AllocResourcesWrapper(int jobId, set<int32_t> & machines) {
        int yarnport = 9090;
        shared_ptr<TTransport> socket(new TSocket("localhost", yarnport));
        shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        YARNTetrischedServiceClient client(protocol);
        // try to allocate some nodes
        try {
            transport->open();
            client.AllocResources(jobId, machines);
            transport->close();
        } catch (TException& tx) {
            printf("ERROR calling YARN : %s\n", tx.what());
        }
    }

public:
    TetrischedServiceHandler() {
        std::vector<int> rackInfo = ReadConfigFile();

        int count = 0;
        for (int i = 0; i < rackInfo.size(); i++) {
            std::vector<MachineResource> rack;
            for(int j = 0; j < rackInfo[i]; j++)
                rack.push_back(MachineResource(count + j));
            racks.push_back(rack);
            count += rackInfo[i];
        }
    }

//    void AddJob(const JobID jobId, const JobType jobType, const int32_t k, const int32_t priority)
    void AddJob(const JobID jobId, const job_t::type jobType, const int32_t k, const int32_t priority, const double duration, const double slowDuration)
    {
        printf("Ready to AddJob()\n");
        if (queue.empty() && GetFreeMachinesNum() >= k) {
            set<int32_t> machines;
            for (int i = 0; i < k; i++)
                machines.insert(GetNextFreeMachine());
            AllocResourcesWrapper(jobId, machines);
        } else {
            // not enough resources or there are some jobs ahead of this job
            queue.push_back(QueueJob(jobId, k));
        }
        printf("Finish AddJob()\n");
    }

    void FreeResources(const std::set<int32_t> & machines)
    {
        printf("Ready to FreeResources()\n");
        for (std::set<int32_t>::iterator it=machines.begin(); it!=machines.end(); ++it)
            FreeMachine(*it);

        while (!queue.empty() && GetFreeMachinesNum() >= queue.front().k) {
            int jobId = queue.front().jobId;
            int k = queue.front().k;
            queue.pop_front();

            set<int32_t> machines;
            for (int i = 0; i < k; i++)
                machines.insert(GetNextFreeMachine());
            AllocResourcesWrapper(jobId, machines);
        }
        printf("Finish FreeResources()\n");
    }
};

int main(int argc, char **argv)
{
    int alschedport = 9091;
    shared_ptr<TetrischedServiceHandler> handler(new TetrischedServiceHandler());
    shared_ptr<TProcessor> processor(new TetrischedServiceProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(alschedport));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}

